
# 复杂度分析

## 冒泡排序

遍历 n 次, 每次执行要和未排好的比较/交换 $n-1, n-2,..., 1$ 次, 复杂度为$O(n^2)$

## 插入排序

遍历 n 次, 每次和前面已经排好的比较 $1, 2, ..., n-1$ 次, 复杂度为$O(n^2)$

## 归并排序

遍历 $\log(n)$ 次(因为每次都将当前数据一分为二, 分 $\log(n)$ 次就会分到头), 每次遍历都将每个组的左右两侧遍历一遍来合并两侧, 每个元素会且仅会被遍历到一次, 复杂度为 $(n\log(n))$

## 快速排序

同归并排序, 遍历 $\log(n)$ 次(因为每次都将当前数据一分为二, 分 $\log(n)$ 次就会分到头), 每次遍历都将每个组的左右两侧遍历一遍来合并两侧, 每个元素会且仅会被遍历到一次, 复杂度为 $(n\log(n))$

## 堆排序

堆的深度为$\log(n)$, 所以每次将元素下沉的复杂度即为 $\log(n)$  
构建树时, 需要对所有非叶节点(约为n/2个)进行一次下沉, 复杂度为 $n\log(n)$  
排序时, 需要遍历 n 个元素, 调换堆顶元素到最后($O(1)$), 并重建堆($O(\log(n-1)),\ O(\log(n-2),\ \dots,\ O(\log(1))$)  
总体复杂度为 $O(n\log(n)$
